# -*- coding: utf-8 -*-
"""model_test02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d9J1FI8ML63XRIesPIZNXsKyxTcja2V3
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import pairwise_distances
import numpy as np
import warnings
warnings.filterwarnings('ignore')
import ipywidgets as widgets
from IPython.display import display

# Load the dataset
file_path = '/content/New_test.csv'
df = pd.read_csv(file_path)

plans_df = pd.read_csv('/content/merged_county_data.csv')

# Clean the Income column to remove '$' and ',' and convert to float
df['Income'] = df['Income'].replace('[\$,]', '', regex=True).astype(float)

# Select relevant features and the target variable
features = ['Age', 'Income', 'Number_of_Devices']
target = 'Current_Internet_Speed'

# Rows with missing values
df.isna().sum()

# Separate the features and target variable
X = df[features]
y = df[target]

# Split the dataset into training and testing sets (80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train the Random Forest model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Define input widgets where users can input their own data
county_input = widgets.Text(value='', placeholder='Enter county name', description='County:')  # New widget for county name input
age_input = widgets.Text(value='', placeholder='Enter your age', description='Age:')
income_input = widgets.Text(value='', placeholder='Enter your income', description='Income:')
devices_input = widgets.Text(value='', placeholder='Enter the number of devices', description='Devices:')

# Button to trigger the prediction
predict_button = widgets.Button(description="Find Plan")

# Output widget to display the prediction result
output = widgets.Output()

"""# Top 3 Plan Finder

- Takes user input for County, Age, Income, and Devices.
- Inputs cannot be empty
- The County name length must be greater than or equal to the first 3 characters.
- Speed prediction is made using machine learning model (random forest regressor).
- The top 3 speed is filtered from the FCC reported plans based on a specified range (500 Mbps up and down) around the predicted speed.
"""

# Define a function to make predictions
def make_prediction(county_name, age, income, no_of_devices):
    try:
        # Convert input values to integers
        age = int(age)
        income = float(income)  # Ensure income is a float
        no_of_devices = int(no_of_devices)

        # Check if any numeric input is 0
        if age == 0 or income == 0 or no_of_devices == 0:
            with output:
                output.clear_output()
                print("No suggestions can be provided because one or more numeric inputs are zero.")
            return

        # Prepare the input data
        input_data = pd.DataFrame({
            'Age': [age],
            'Income': [income],
            'Number_of_Devices': [no_of_devices]
        })

        # Predict the speed
        prediction = model.predict(input_data)[0]

        # Check if the county_name input is valid
        if not county_name.strip() or len(county_name.strip()) < 3:
            with output:
                output.clear_output()
                print("Please enter at least the first 3 characters of your county.")
            return

        # Filter the dataset based on the county name
        filtered_df = plans_df[plans_df['county_name'].str.contains(county_name, case=False, na=False)]

        # Check if the filtered DataFrame is empty or if the county name does not match exactly
        if filtered_df.empty:
            with output:
                output.clear_output()
                print(f"No data found for the specified county: '{county_name}'.")
            return

        # Calculate predictions from each tree and standard deviation
        preds_per_tree = np.array([tree.predict(input_data)[0] for tree in model.estimators_])
        mean_pred = np.mean(preds_per_tree)
        std_dev = np.std(preds_per_tree)

        # Estimating Confidence Score
        if std_dev == 0:
            confidence_score = 100.0  # If all predictions are the same, full confidence
        else:
            confidence_score = 100.0 - (std_dev / mean_pred) * 100

        confidence_score = max(0, confidence_score)

        # Display the top 3 unique predicted speeds and their confidence scores
        top_n = 3

        # Find the closest matches to the predicted speed within a range
        range_min = prediction - 500.0
        range_max = prediction + 500.0
        matches = filtered_df[(filtered_df['max_advertised_download_speed'] >= range_min) &
                           (filtered_df['max_advertised_download_speed'] <= range_max)]

        if not matches.empty:
            # Keep only the unique values
            unique_matches = matches.drop_duplicates(subset='max_advertised_download_speed')

            # Sort unique matches by the absolute difference from the predicted speed
            sorted_unique_matches = unique_matches.iloc[(unique_matches['max_advertised_download_speed'] - prediction).abs().argsort()]

            # Select the top 3 unique closest speeds
            top_unique_matches = sorted_unique_matches.head(top_n)
            if len(top_unique_matches) < top_n:
                remaining_matches = unique_matches[~unique_matches.isin(top_unique_matches)]
                top_unique_matches = pd.concat([top_unique_matches, remaining_matches.head(top_n - len(top_unique_matches))])
            # Sort the results by download speed in ascending order
            top_unique_matches = top_unique_matches.sort_values(by='max_advertised_download_speed', ascending=True)
        else:
            top_unique_matches = pd.Series()  # Empty series if no matches


        # Clear previous output and display the results
        with output:
            output.clear_output()
            print(f"Suggested Speed: {prediction:.2f} Mbps")
            print(f"Confidence Score: {confidence_score:.2f}%")
            print("\nTop 3 Unique Matches from Dataset:")
            if not top_unique_matches.empty:
                for _, row in top_unique_matches.iterrows():
                    print(f" Brand Name: {row['brand_name']}\n",
                          f"Download Speed: {row['max_advertised_download_speed']:.2f} Mbps\n",
                          f"Upload Speed: {row['max_advertised_upload_speed']:.2f} Mbps\n")
            else:
                print("No unique exact matches found.")
    except ValueError:
        with output:
            output.clear_output()
            print("Please enter valid numeric values.")

# Define the button click event
def on_button_clicked(b):
        make_prediction(county_input.value, age_input.value, income_input.value, devices_input.value)

# Attach the event to the button
predict_button.on_click(on_button_clicked)

# Display the widgets
display(county_input, age_input, income_input, devices_input, predict_button, output)